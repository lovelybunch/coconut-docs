# 🥥 Coconut Docs

> Coconut Docs

## GAIT: Agent-Native Source Control Management System

### Product Specification v2.1 - File-First Architecture

#### Executive Summary

GAIT (Git-Adjacent Intent Tracking) is a revolutionary source control management system designed for the era of agentic engineering and multi-role collaboration. Unlike traditional VCS that focuses on line-by-line changes, GAIT treats intent, plans, experiments, and product operations as first-class citizens alongside code.

**v1 Philosophy**: Start simple with file-based storage in `.gait/` directory, enabling immediate adoption without infrastructure requirements. All data lives alongside your code, versioned with git.

**v2 Evolution**: Progressive enhancement with optional PostgreSQL for advanced features like cross-repo dashboards and real-time collaboration, while maintaining files as the source of truth.

#### Vision Statement

Transform software development from a code-centric to an intent-centric workflow, where product managers, designers, engineers, and AI agents collaborate seamlessly through a unified interface that bridges the gap between business requirements and technical implementation.

***

### Core Problems Solved

#### Traditional SCM Limitations

* **Line diffs ≠ intent**: Current systems track what changed, not why or how
* **Semantic-blind merges**: Text-based merging misses structural understanding
* **No provenance**: Missing context about prompts, tools, datasets, and decision rationale
* **Poor coordination**: Multiple agents/humans racing on files without task-level isolation
* **Missing governance**: No built-in risk gates, policy checks, or review requirements
* **Disconnected product ops**: PRDs, experiments, and feature flags live separately from code

#### Multi-Role Collaboration Gaps

* Non-technical stakeholders excluded from technical planning
* AI agents lack structured ways to propose and track changes
* Experiments and feature flags managed in isolation from code changes
* No unified view of product delivery across roles

***

### Core Architecture

#### Technology Stack

##### v1 - File-First (MVP)

**No database required - everything in `.gait/` directory**

**Full-Stack Framework**

* **Next.js 14+**: Unified React framework with App Router
* **TypeScript**: End-to-end type safety
* **File Storage**: Markdown files with YAML frontmatter in `.gait/`
* **Local State**: React Context + localStorage for UI state

**UI & Design System**

* **shadcn/ui**: Modern, accessible component library
* **Tailwind CSS**: Utility-first styling
* **Radix UI**: Headless UI primitives
* **Lucide Icons**: Comprehensive icon set
* **Recharts**: Data visualization
* **cmdk**: Command palette for power users

**Data Layer (v1)**

* **gray-matter**: Parse YAML frontmatter from markdown
* **fs/promises**: Async file operations
* **chokidar**: File system watching for real-time updates
* **fuse.js**: Client-side fuzzy search
* **json-schema**: Validation for YAML frontmatter

**AI Integration**

* **Vercel AI SDK**: Unified AI integration
* **OpenAI/Anthropic SDKs**: Direct model access

**Development**

* **pnpm**: Fast, efficient package management
* **Docker**: Optional dev containers
* **Vitest**: Fast unit testing

##### v2 - Progressive Enhancement (Future)

**Optional PostgreSQL for advanced features**

* **PostgreSQL**: Metadata indexing and cross-repo queries
* **Prisma ORM**: Type-safe database access
* **Redis**: Caching and real-time features
* **BullMQ**: Background job processing
* **Socket.io/Pusher**: Real-time collaboration

#### Storage Architecture

##### v1 - File-Based Storage Pattern

```typescript
// Abstract storage interface - implement once, swap later
interface StorageAdapter {
  // Core CRUD operations
  createCP(cp: ChangeProposal): Promise<void>;
  getCP(id: string): Promise<ChangeProposal | null>;
  updateCP(id: string, cp: Partial<ChangeProposal>): Promise<void>;
  deleteCP(id: string): Promise<void>;
  
  // Query operations
  listCPs(filter?: CPFilter): Promise<ChangeProposal[]>;
  searchCPs(query: string): Promise<ChangeProposal[]>;
  
  // Bulk operations
  getCPsByStatus(status: ProposalStatus): Promise<ChangeProposal[]>;
  getCPsByAuthor(authorId: string): Promise<ChangeProposal[]>;
}

// v1 Implementation - Pure file-based
export class FileStorageAdapter implements StorageAdapter {
  private basePath = '.gait/proposals';
  
  async createCP(cp: ChangeProposal): Promise<void> {
    const { content, ...frontmatter } = cp;
    const markdown = matter.stringify(content || '', frontmatter);
    await fs.writeFile(`${this.basePath}/${cp.id}.md`, markdown);
  }
  
  async listCPs(filter?: CPFilter): Promise<ChangeProposal[]> {
    const files = await fs.readdir(this.basePath);
    const proposals = await Promise.all(
      files
        .filter(f => f.endsWith('.md'))
        .map(f => this.getCP(f.replace('.md', '')))
    );
    
    // Apply filters in memory
    return proposals.filter(cp => {
      if (!cp) return false;
      if (filter?.status && cp.status !== filter.status) return false;
      if (filter?.author && cp.author.id !== filter.author) return false;
      return true;
    });
  }
  
  async searchCPs(query: string): Promise<ChangeProposal[]> {
    const allCPs = await this.listCPs();
    // Use Fuse.js for fuzzy searching
    const fuse = new Fuse(allCPs, {
      keys: ['intent', 'content', 'author.name'],
      threshold: 0.3
    });
    return fuse.search(query).map(result => result.item);
  }
}

// v2 Implementation - Hybrid with PostgreSQL caching
export class HybridStorageAdapter implements StorageAdapter {
  private fileAdapter = new FileStorageAdapter();
  private db = new PrismaClient();
  
  async createCP(cp: ChangeProposal): Promise<void> {
    // Write to file (source of truth)
    await this.fileAdapter.createCP(cp);
    
    // Index in database for fast queries
    await this.db.proposal.create({
      data: {
        cpId: cp.id,
        intent: cp.intent,
        status: cp.status,
        authorId: cp.author.id,
        contentPath: `${cp.id}.md`
      }
    });
  }
  
  async listCPs(filter?: CPFilter): Promise<ChangeProposal[]> {
    // Try database first for speed
    try {
      const proposals = await this.db.proposal.findMany({
        where: filter,
        orderBy: { createdAt: 'desc' }
      });
      // Hydrate with full content from files
      return Promise.all(
        proposals.map(p => this.fileAdapter.getCP(p.cpId))
      );
    } catch {
      // Fallback to file-based if DB unavailable
      return this.fileAdapter.listCPs(filter);
    }
  }
}
```

#### Repository Structure

```
project-root/
├── .gait/                      # GAIT data directory (v1 - only storage)
│   ├── config.json            # Repository configuration
│   ├── proposals/             # Change proposals as markdown files
│   │   ├── cp-2024-001.md
│   │   ├── cp-2024-002.md
│   │   └── ...
│   ├── specs/                 # Product specifications
│   │   └── auth/
│   │       └── 2fa.spec.md
│   ├── flags/                 # Feature flag definitions
│   │   └── flags.json
│   ├── experiments/           # Experiment configurations
│   │   └── experiments.json
│   ├── templates/             # CP and spec templates
│   │   ├── feature.template.md
│   │   └── bugfix.template.md
│   └── .gitignore            # Ignore local caches
│
├── gait-app/                  # Next.js application (can be separate repo)
│   ├── app/                   # Next.js App Router
│   │   ├── (dashboard)/      # Authenticated routes with sidebar
│   │   │   ├── layout.tsx    # Dashboard layout with shadcn sidebar
│   │   │   ├── page.tsx      # Home dashboard
│   │   │   ├── proposals/    # CP management views
│   │   │   ├── experiments/  # A/B testing interface
│   │   │   ├── flags/        # Feature flag management
│   │   │   ├── analytics/    # Metrics and insights
│   │   │   └── settings/     # Configuration
│   │   ├── api/              # REST API routes
│   │   │   └── v1/           # Versioned endpoints
│   │   └── layout.tsx        # Root layout
│   ├── components/
│   │   ├── ui/               # shadcn/ui components
│   │   ├── features/         # Feature-specific components
│   │   └── app-sidebar.tsx   # Main navigation
│   ├── lib/
│   │   ├── storage/          # Storage adapter implementation
│   │   │   ├── adapter.ts    # Abstract interface
│   │   │   ├── file.ts       # File-based implementation
│   │   │   └── hybrid.ts     # v2: PostgreSQL + files
│   │   ├── ai/               # AI service integration
│   │   └── utils/            # Utilities
│   └── package.json
│
└── your-actual-code/          # Your project files
```

***

### Core Primitives

#### 1. Change Proposal (CP) - v1 File Format

Change Proposals are stored as markdown files with YAML frontmatter in `.gait/proposals/`:

````markdown
---
# Required fields
id: cp-2024-001
version: "1.0"
intent: Add TOTP Two-Factor Authentication
createdAt: '2024-08-16T10:30:00Z'
updatedAt: '2024-08-16T14:45:00Z'
status: in-review        # draft | proposed | in-review | approved | merged | rejected
priority: high           # low | medium | high | critical

# Author information
author:
  id: sarah-chen
  name: Sarah Chen
  email: sarah@company.com
  role: product-manager  # engineer | product-manager | designer | engineering-manager | agent
  type: human           # human | agent

# Product context (optional)
productSpec:
  ref: specs/auth/2fa-implementation
  goals:
    - Improve account security
    - Reduce support tickets for compromised accounts
  successMetrics:
    - name: adoption_rate
      target: "25% within 60 days"
      type: business
    - name: support_tickets
      target: "50% reduction in account recovery"
      type: business
  platforms: [web, ios, android]

# Implementation plan
plan:
  estimatedDuration: "2 weeks"
  dependencies: []
  steps:
    - id: step-1
      type: code
      description: Implement TOTP secret generation and storage
      assignee: alice@company.com
      status: completed
      evidence:
        - type: test-results
          data: "100% test coverage on auth module"
    - id: step-2
      type: code
      description: Build QR code generation and scanning
      status: in-progress
      dependencies: [step-1]
    - id: step-3
      type: review
      description: Security audit of implementation
      status: pending
      dependencies: [step-1, step-2]

# Feature flags (optional)
featureFlags:
  - key: auth.totp.enabled
    type: boolean
    defaultValue: false
    description: Enable TOTP authentication feature
    rollout:
      start: 0
      target: 100
      increment: 10
      interval: daily

# Experiments (optional)
experiments:
  - id: totp_onboarding_flow
    name: TOTP Onboarding Flow Test
    hypothesis: Inline setup increases adoption vs. settings page
    variants: [inline, settings]
    allocation: [50, 50]
    primaryMetric: totp_setup_completion
    status: draft

# Governance
policies:
  - type: security-review
    status: pending
    reviewer: security-team
  - type: code-review
    status: approved
    reviewer: alice@company.com
    approvedAt: '2024-08-16T13:00:00Z'

# AI interactions
aiInteractions:
  - id: ai-001
    timestamp: '2024-08-16T11:00:00Z'
    type: suggestion
    model: claude-3-opus
    prompt: "Review the security implications of this implementation"
    accepted: true

# Metadata
tags: [security, authentication, 2fa]
labels:
  - name: breaking-change
    color: red
  - name: user-facing
    color: blue

# Comments (stored inline for v1)
comments:
  - id: comment-001
    author: security-team
    timestamp: '2024-08-16T12:00:00Z'
    text: "Please ensure TOTP secrets are encrypted at rest"
  - id: comment-002
    author: mobile-team
    timestamp: '2024-08-16T13:30:00Z'
    text: "We'll need 2 sprints for the mobile implementation"
---

# Add TOTP Two-Factor Authentication

## Problem Statement
Our users are increasingly concerned about account security. We've seen a 15% increase in support tickets related to account breaches in Q3 2024. Industry standards now expect 2FA as a baseline security feature.

## Proposed Solution
Implement Time-based One-Time Password (TOTP) authentication as an optional security feature for all user accounts.

### Key Features
- **QR Code Setup**: Simple scanning flow for mobile authenticator apps
- **Backup Codes**: 10 single-use recovery codes for account access
- **Remember Device**: Optional 30-day trusted device cookies
- **Graceful Degradation**: SMS fallback for users without authenticator apps

## Implementation Details

### Backend Changes
```typescript
// New auth service methods
interface AuthService {
  generateTOTPSecret(userId: string): TOTPSecret;
  verifyTOTP(userId: string, token: string): boolean;
  generateBackupCodes(userId: string): string[];
}
````

#### Database Schema

```sql
ALTER TABLE users ADD COLUMN totp_secret VARCHAR(32);
ALTER TABLE users ADD COLUMN totp_enabled BOOLEAN DEFAULT FALSE;
```

### Testing Strategy

* [ ] Unit tests for TOTP generation/validation
* [ ] Integration tests for full auth flow
* [ ] Security penetration testing
* [ ] Load testing for 10k concurrent validations

### Rollout Plan

1. **Week 1**: Deploy to staging, internal testing
2. **Week 2**: 1% rollout to beta users
3. **Week 3**: 10% rollout, monitor metrics
4. **Week 4**: 50% rollout if metrics are positive
5. **Week 5**: 100% availability (still opt-in)

### AI Assistant Notes

*Last reviewed: 2024-08-16 14:45:00*

The implementation plan looks solid. Consider these additional security measures:

1. Rate limiting on TOTP attempts (max 5 per minute)
2. Notification email when 2FA is disabled
3. Require current password to enable/disable 2FA

````

### 2. Configuration File (.gait/config.json)

```json
{
  "version": "1.0.0",
  "mode": "git-sidecar",
  "initialized": "2024-08-16T10:00:00Z",
  
  "repository": {
    "type": "git",
    "remote": "https://github.com/company/project.git",
    "mainBranch": "main",
    "syncStrategy": "manual"
  },
  
  "ai": {
    "enabled": true,
    "provider": "anthropic",
    "model": "claude-3-opus-20240229",
    "prompts": {
      "cpReview": "Review this change proposal for completeness, security, and best practices.",
      "implementation": "Suggest implementation steps for this change.",
      "explain": "Explain this technical change to a non-technical audience."
    }
  },
  
  "policies": {
    "requireApproval": true,
    "minReviewers": 1,
    "autoMerge": false,
    "codeOwners": [
      {
        "pattern": "src/auth/*",
        "owners": ["security-team"],
        "minApprovals": 2
      }
    ]
  },
  
  "team": {
    "members": [
      {
        "id": "sarah-chen",
        "name": "Sarah Chen",
        "email": "sarah@company.com",
        "role": "product-manager"
      }
    ]
  }
}
````

#### 3. Feature Flags (.gait/flags/flags.json)

```json
{
  "flags": [
    {
      "key": "auth.totp.enabled",
      "name": "TOTP Authentication",
      "description": "Enable TOTP two-factor authentication",
      "type": "boolean",
      "defaultValue": false,
      "environments": {
        "development": true,
        "staging": true,
        "production": false
      },
      "targeting": {
        "rules": [
          {
            "audience": "beta_users",
            "value": true
          }
        ]
      },
      "owner": "security-team",
      "createdAt": "2024-08-16T10:00:00Z",
      "updatedAt": "2024-08-16T10:00:00Z"
    }
  ]
}
```

***

### User Interface Components

#### Web UI for v1 - File-Based Operations

The web UI reads and writes directly to the `.gait/` directory using Next.js API routes:

```typescript
// app/api/v1/proposals/route.ts
import { FileStorageAdapter } from '@/lib/storage/file';
import { NextRequest, NextResponse } from 'next/server';

const storage = new FileStorageAdapter();

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const status = searchParams.get('status');
  const author = searchParams.get('author');
  
  const proposals = await storage.listCPs({
    status: status as ProposalStatus,
    author
  });
  
  return NextResponse.json({ data: proposals });
}

export async function POST(request: NextRequest) {
  const body = await request.json();
  const cp = await storage.createCP(body);
  return NextResponse.json(cp, { status: 201 });
}
```

```typescript
// components/features/proposal-list.tsx
import { useQuery } from '@tanstack/react-query';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';

export function ProposalList() {
  const { data: proposals, isLoading } = useQuery({
    queryKey: ['proposals'],
    queryFn: async () => {
      const res = await fetch('/api/v1/proposals');
      return res.json();
    },
    // Poll for file system changes
    refetchInterval: 5000
  });
  
  if (isLoading) return <div>Loading proposals...</div>;
  
  return (
    <div className="grid gap-4">
      {proposals?.data.map((cp: ChangeProposal) => (
        <Card key={cp.id} className="p-4">
          <div className="flex justify-between items-start">
            <div>
              <h3 className="font-semibold">{cp.intent}</h3>
              <p className="text-sm text-muted-foreground">
                {cp.id} • {cp.author.name}
              </p>
            </div>
            <Badge variant={getStatusVariant(cp.status)}>
              {cp.status}
            </Badge>
          </div>
        </Card>
      ))}
    </div>
  );
}
```

#### File System Watching for Real-time Updates

```typescript
// lib/storage/watcher.ts
import { watch } from 'chokidar';
import { EventEmitter } from 'events';

export class FileWatcher extends EventEmitter {
  private watcher: any;
  
  constructor(private basePath = '.gait') {
    super();
    this.initWatcher();
  }
  
  private initWatcher() {
    this.watcher = watch(`${this.basePath}/**/*.md`, {
      persistent: true,
      ignoreInitial: true
    });
    
    this.watcher
      .on('add', (path: string) => this.emit('cp:created', path))
      .on('change', (path: string) => this.emit('cp:updated', path))
      .on('unlink', (path: string) => this.emit('cp:deleted', path));
  }
}

// Use in API route for Server-Sent Events
// app/api/v1/proposals/stream/route.ts
export async function GET() {
  const encoder = new TextEncoder();
  const watcher = new FileWatcher();
  
  const stream = new ReadableStream({
    start(controller) {
      watcher.on('cp:updated', (path) => {
        controller.enqueue(
          encoder.encode(`data: ${JSON.stringify({ type: 'update', path })}\n\n`)
        );
      });
    }
  });
  
  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

#### shadcn/ui Sidebar Navigation (Same for v1 and v2)

```typescript
// components/app-sidebar.tsx
import {
  Sidebar,
  SidebarContent,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarHeader,
  SidebarFooter,
} from "@/components/ui/sidebar"

export function AppSidebar() {
  return (
    <Sidebar>
      <SidebarHeader>
        <SidebarMenu>
          <SidebarMenuItem>
            <SidebarMenuButton size="lg">
              <GitBranch className="size-6" />
              <div className="flex flex-col gap-0.5">
                <span className="font-semibold">GAIT</span>
                <span className="text-xs text-muted-foreground">v1.0 - File-based</span>
              </div>
            </SidebarMenuButton>
          </SidebarMenuItem>
        </SidebarMenu>
      </SidebarHeader>
      
      <SidebarContent>
        <SidebarGroup>
          <SidebarGroupLabel>Main</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              <SidebarMenuItem>
                <SidebarMenuButton asChild>
                  <Link href="/">
                    <Home />
                    <span>Dashboard</span>
                  </Link>
                </SidebarMenuButton>
              </SidebarMenuItem>
              <SidebarMenuItem>
                <SidebarMenuButton asChild>
                  <Link href="/proposals">
                    <GitBranch />
                    <span>Proposals</span>
                  </Link>
                </SidebarMenuButton>
              </SidebarMenuItem>
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
      </SidebarContent>
      
      <SidebarFooter>
        <SidebarMenu>
          <SidebarMenuItem>
            <AIAssistantTrigger />
          </SidebarMenuItem>
          <SidebarMenuItem>
            <UserMenu />
          </SidebarMenuItem>
        </SidebarMenu>
      </SidebarFooter>
    </Sidebar>
  );
}
```

***

### Command Line Interface

#### Core Commands (v1 - File-based)

```bash
# Initialize GAIT in a repository (creates .gait/ directory)
gait init [--template=basic|advanced]

# Create a new Change Proposal (writes to .gait/proposals/)
gait propose "Add TOTP 2FA" [--author=email] [--type=feature|bugfix|refactor]
gait propose --interactive  # AI-assisted proposal creation

# List and filter CPs (reads from .gait/proposals/)
gait list [--status=draft|proposed|approved] [--author=name] [--json]
gait search "authentication"  # Search through markdown files

# Show CP details (reads .gait/proposals/cp-xxx.md)
gait show cp-001 [--format=json|yaml|md]
gait diff cp-001 cp-002  # Compare proposals

# Review and approve (updates YAML frontmatter)
gait review cp-001 [--ai-assist]
gait approve cp-001 [--message="LGTM"]
gait reject cp-001 [--reason="Needs security review"]

# AI operations (results saved to frontmatter)
gait ai review cp-001 [--focus=security|performance|ux]
gait ai suggest "Implementation for OAuth integration"
gait ai explain cp-001 --audience=non-technical

# Feature flags (reads/writes .gait/flags/flags.json)
gait flag create auth.totp.enabled --type=boolean --default=false
gait flag set auth.totp.enabled --value=true

# Experiments (reads/writes .gait/experiments/)
gait experiment create "Checkout flow A/B test"
gait experiment status exp-001

# Git sync
gait sync  # Commits .gait/ changes
gait push  # Push to remote
```

***

### API Design (v1 - File-based)

#### RESTful Endpoints

All v1 endpoints work directly with files in `.gait/`:

```typescript
// File-based operations
GET    /api/v1/proposals              // List proposals (reads .gait/proposals/)
POST   /api/v1/proposals              // Create proposal (writes .gait/proposals/cp-xxx.md)
GET    /api/v1/proposals/:id          // Get proposal (reads specific file)
PATCH  /api/v1/proposals/:id          // Update proposal (modifies file)
DELETE /api/v1/proposals/:id          // Delete proposal (removes file)

// Search (in-memory using Fuse.js)
GET    /api/v1/search?q=term          // Search across all markdown files

// AI Integration (results saved to files)
POST   /api/v1/ai/review              // Review CP, save to frontmatter
POST   /api/v1/ai/suggest             // Get suggestions

// Feature Flags (reads/writes .gait/flags/flags.json)
GET    /api/v1/flags                  // List all flags
POST   /api/v1/flags                  // Create flag
PATCH  /api/v1/flags/:key             // Update flag

// Experiments (reads/writes .gait/experiments/)
GET    /api/v1/experiments            // List experiments
POST   /api/v1/experiments            // Create experiment

// File watching for real-time updates
GET    /api/v1/proposals/stream       // Server-sent events for file changes
```

***

### Development & Deployment

#### v1 Package Configuration (No Database)

```json
// package.json - v1 File-based
{
  "name": "gait",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit",
    "test": "vitest",
    
    "gait:init": "tsx scripts/init-gait.ts",
    "gait:validate": "tsx scripts/validate-files.ts",
    
    "ui:add": "pnpm dlx shadcn-ui@latest add"
  },
  
  "dependencies": {
    // Next.js & React
    "next": "^14.1.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    
    // UI Components (shadcn/ui)
    "@radix-ui/react-accordion": "^1.1.2",
    "@radix-ui/react-avatar": "^1.0.4",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-scroll-area": "^1.0.5",
    "@radix-ui/react-sidebar": "^1.0.0",
    "@radix-ui/react-tabs": "^1.0.4",
    
    // Styling
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "lucide-react": "^0.309.0",
    "tailwind-merge": "^2.2.0",
    
    // File Operations (v1 Core)
    "gray-matter": "^4.0.3",         // Parse YAML frontmatter
    "chokidar": "^3.6.0",            // File watching
    "fuse.js": "^7.0.0",             // Client-side search
    "zod": "^3.22.4",                // Schema validation
    "ajv": "^8.12.0",                // JSON schema validation
    
    // AI Integration
    "ai": "^3.0.0",
    "@anthropic-ai/sdk": "^0.20.0",
    "openai": "^4.28.0",
    
    // Data fetching
    "@tanstack/react-query": "^5.17.9",
    
    // Utilities
    "date-fns": "^3.3.1",
    "react-markdown": "^9.0.1",
    "recharts": "^2.10.4",
    
    // CLI Dependencies
    "commander": "^11.1.0",
    "chalk": "^5.3.0",
    "inquirer": "^9.2.12",
    "ora": "^8.0.1"
  },
  
  "devDependencies": {
    "@types/node": "^20.11.0",
    "@types/react": "^18.2.47",
    "autoprefixer": "^10.4.17",
    "eslint": "^8.56.0",
    "eslint-config-next": "14.1.0",
    "postcss": "^8.4.33",
    "prettier": "^3.2.4",
    "tailwindcss": "^3.4.1",
    "tsx": "^4.7.0",
    "typescript": "^5.3.3",
    "vitest": "^1.2.1"
  }
}
```

#### v2 Additional Dependencies (Future)

```json
// Additional dependencies for v2 (PostgreSQL enhancement)
{
  "dependencies": {
    // ... all v1 dependencies plus:
    
    // Database (v2 only)
    "@prisma/client": "^5.8.1",
    "@t3-oss/env-nextjs": "^0.7.3",
    
    // API (v2 enhancement)
    "@trpc/client": "^10.45.0",
    "@trpc/next": "^10.45.0",
    "@trpc/react-query": "^10.45.0",
    "@trpc/server": "^10.45.0",
    
    // Real-time (v2 feature)
    "pusher": "^5.2.0",
    "pusher-js": "^8.4.0",
    
    // Background Jobs (v2 feature)
    "bullmq": "^5.1.0"
  },
  
  "devDependencies": {
    // ... all v1 devDependencies plus:
    "prisma": "^5.8.1"
  },
  
  "scripts": {
    // v2 additions:
    "db:push": "prisma db push",
    "db:migrate": "prisma migrate dev",
    "db:studio": "prisma studio",
    "db:seed": "tsx prisma/seed.ts"
  }
}
```

#### Dev Container Configuration (v1)

```json
// .devcontainer/devcontainer.json - v1 (no database)
{
  "name": "GAIT Development (v1 - File-based)",
  "image": "mcr.microsoft.com/devcontainers/typescript-node:20",
  
  "features": {
    "ghcr.io/devcontainers/features/git:1": {}
  },
  
  "customizations": {
    "vscode": {
      "extensions": [
        "dbaeumer.vscode-eslint",
        "esbenp.prettier-vscode",
        "bradlc.vscode-tailwindcss",
        "ms-vscode.vscode-typescript-next",
        "unifiedjs.vscode-mdx"
      ],
      "settings": {
        "typescript.tsdk": "node_modules/typescript/lib",
        "editor.defaultFormatter": "esbenp.prettier-vscode",
        "editor.formatOnSave": true
      }
    }
  },
  
  "forwardPorts": [3000],
  "postCreateCommand": "pnpm install && pnpm gait:init",
  "remoteUser": "node"
}
```

***

### Migration & Adoption Strategy

#### Phase 1: v1 MVP - File-based (Weeks 1-4)

**Goal**: Launch quickly with zero infrastructure

**Core Features:**

* ✅ Next.js app with shadcn/ui
* ✅ File-based storage in `.gait/` directory
* ✅ Markdown files with YAML frontmatter
* ✅ Basic CLI: init, propose, list, show
* ✅ Web UI: View and create proposals
* ✅ AI chat integration
* ✅ Local search with Fuse.js
* ✅ Git synchronization

**What v1 Can Do:**

* Single repository CP management
* Full CRUD operations on proposals
* AI-assisted reviews and suggestions
* Feature flag definitions
* Basic experiments tracking
* Team collaboration via git

**v1 Limitations (Addressed in v2):**

* No cross-repository dashboard
* Search performance degrades with 100+ CPs
* No real-time collaboration (must refresh)
* No advanced analytics
* No background jobs

#### Phase 2: v2 Enhancement - Hybrid Storage (Weeks 5-8)

**Goal**: Add PostgreSQL for scale while keeping files as source of truth

**New Capabilities:**

* PostgreSQL indexing for fast queries
* Cross-repository dashboards
* Real-time updates via WebSockets
* Advanced search and filtering
* Analytics and metrics aggregation
* Background job processing
* Audit trails

**Migration Path:**

```typescript
// Easy migration from v1 to v2
// 1. Keep all existing files
// 2. Add PostgreSQL
// 3. Run indexing script
await indexExistingFiles();

// 4. Switch storage adapter
const storage = process.env.USE_DB 
  ? new HybridStorageAdapter()  // v2
  : new FileStorageAdapter();     // v1

// Files remain source of truth!
```

#### Phase 3: Enterprise Features (Weeks 9-12)

**Goal**: Production-ready for large teams

* SSO/SAML authentication
* Role-based access control
* Compliance reporting
* Custom workflows
* Advanced AI agents
* Multi-region support

***

### Key Differentiators: v1 File-First Approach

#### Why File-First Wins

1. **Zero Infrastructure Barrier**
   * No database to set up
   * No migrations to run
   * Works immediately after `git clone`

2. **Git-Native by Design**
   * Everything versions with your code
   * Conflicts resolved through git
   * Full history in version control
   * Works offline

3. **Progressive Enhancement**
   * Start simple, add complexity when needed
   * Files always remain source of truth
   * Database becomes an optional index
   * No data migration required

4. **Developer Friendly**
   * Edit proposals in your IDE
   * Script against simple markdown files
   * Use standard Unix tools (grep, sed, awk)
   * Backup is just copying files

#### Example: Working with v1 Files

```bash
# Find all high-priority proposals
grep -l "priority: high" .gait/proposals/*.md

# Count proposals by status
grep "status:" .gait/proposals/*.md | cut -d: -f3 | sort | uniq -c

# Quick edit in your editor
vim .gait/proposals/cp-2024-001.md

# See what changed
git diff .gait/proposals/

# Commit changes
git add .gait/ && git commit -m "Updated CP status"
```

***

### Security & Compliance (v1 Considerations)

#### v1 Security Model

* **File Permissions**: Rely on OS file permissions
* **Git Access Control**: Use existing git repository permissions
* **API Authentication**: NextAuth.js with local providers
* **Secrets**: Environment variables only (no database credentials needed)

#### v2 Security Enhancements

* Database-level access control
* Row-level security policies
* Encrypted fields for sensitive data
* Comprehensive audit logging

***

### Performance Characteristics

#### v1 Performance Profile

| Operation    | File Count | Performance        |
| ------------ | ---------- | ------------------ |
| List all CPs | 10         | \~10ms             |
| List all CPs | 100        | \~100ms            |
| List all CPs | 1000       | \~1s (needs v2)    |
| Search       | 100        | \~50ms (in-memory) |
| Create CP    | Any        | \~20ms             |
| Update CP    | Any        | \~20ms             |

#### When to Upgrade to v2

* More than 100 active proposals
* Need cross-repo visibility
* Require real-time collaboration
* Want advanced analytics
* Need background processing

***

### Implementation Checklist for v1

#### Week 1: Foundation

* [ ] Initialize Next.js project with TypeScript
* [ ] Set up shadcn/ui components
* [ ] Create `.gait/` directory structure
* [ ] Implement `FileStorageAdapter` class
* [ ] Build proposal list view
* [ ] Add proposal creation form

#### Week 2: CLI & Core Features

* [ ] Create CLI with Commander.js
* [ ] Implement `gait init` command
* [ ] Implement `gait propose` command
* [ ] Add markdown parsing with gray-matter
* [ ] Build proposal detail view
* [ ] Add search with Fuse.js

#### Week 3: AI & Collaboration

* [ ] Integrate AI SDK (Anthropic/OpenAI)
* [ ] Add AI chat panel
* [ ] Implement review/approve commands
* [ ] Add comment system (in frontmatter)
* [ ] Build settings page
* [ ] Add file watching for auto-refresh

#### Week 4: Polish & Testing

* [ ] Add feature flags management
* [ ] Create experiment tracking
* [ ] Write documentation
* [ ] Add tests for storage adapter
* [ ] Create example templates
* [ ] Deploy v1 MVP

***

### Example v1 Implementation Files

#### Storage Adapter Implementation

```typescript
// lib/storage/file.ts
import fs from 'fs/promises';
import path from 'path';
import matter from 'gray-matter';
import { z } from 'zod';
import Fuse from 'fuse.js';

export class FileStorageAdapter implements StorageAdapter {
  private basePath: string;
  
  constructor(basePath = '.gait') {
    this.basePath = basePath;
  }
  
  async ensureDirectories() {
    const dirs = ['proposals', 'specs', 'flags', 'experiments', 'templates'];
    for (const dir of dirs) {
      await fs.mkdir(path.join(this.basePath, dir), { recursive: true });
    }
  }
  
  async createCP(cp: ChangeProposal): Promise<void> {
    await this.ensureDirectories();
    
    const { content, ...frontmatter } = cp;
    const markdown = matter.stringify(content || '', frontmatter);
    const filePath = path.join(this.basePath, 'proposals', `${cp.id}.md`);
    
    await fs.writeFile(filePath, markdown, 'utf-8');
  }
  
  async getCP(id: string): Promise<ChangeProposal | null> {
    try {
      const filePath = path.join(this.basePath, 'proposals', `${id}.md`);
      const fileContent = await fs.readFile(filePath, 'utf-8');
      const { data, content } = matter(fileContent);
      
      return {
        ...data,
        content
      } as ChangeProposal;
    } catch (error) {
      if (error.code === 'ENOENT') return null;
      throw error;
    }
  }
  
  async listCPs(filter?: CPFilter): Promise<ChangeProposal[]> {
    const proposalsDir = path.join(this.basePath, 'proposals');
    
    try {
      const files = await fs.readdir(proposalsDir);
      const proposals = await Promise.all(
        files
          .filter(f => f.endsWith('.md'))
          .map(async (file) => {
            const content = await fs.readFile(
              path.join(proposalsDir, file), 
              'utf-8'
            );
            const { data, content: body } = matter(content);
            return { ...data, content: body } as ChangeProposal;
          })
      );
      
      // Apply filters
      return proposals.filter(cp => {
        if (filter?.status && cp.status !== filter.status) return false;
        if (filter?.author && cp.author.id !== filter.author) return false;
        if (filter?.priority && cp.priority !== filter.priority) return false;
        return true;
      });
    } catch (error) {
      if (error.code === 'ENOENT') return [];
      throw error;
    }
  }
  
  async searchCPs(query: string): Promise<ChangeProposal[]> {
    const allCPs = await this.listCPs();
    
    const fuse = new Fuse(allCPs, {
      keys: [
        { name: 'intent', weight: 2 },
        { name: 'content', weight: 1 },
        { name: 'author.name', weight: 0.5 },
        { name: 'tags', weight: 1 }
      ],
      threshold: 0.3,
      includeScore: true
    });
    
    return fuse.search(query).map(result => result.item);
  }
  
  async updateCP(id: string, updates: Partial<ChangeProposal>): Promise<void> {
    const existing = await this.getCP(id);
    if (!existing) throw new Error(`CP ${id} not found`);
    
    const updated = {
      ...existing,
      ...updates,
      updatedAt: new Date().toISOString()
    };
    
    await this.createCP(updated);
  }
}
```

***

### Conclusion

GAIT v2.1 specification embraces a **file-first architecture** that eliminates infrastructure barriers while maintaining a clear path to scale. By storing everything in `.gait/` directories as markdown files with YAML frontmatter, teams can adopt GAIT immediately without any database setup.

#### v1 Benefits (Shipping Now)

* **Zero infrastructure** - Just files in a directory
* **Git-native** - Everything versions with your code
* **Immediate value** - Start using in minutes
* **Full functionality** - AI, proposals, flags, experiments all work
* **Simple deployment** - Just a Next.js app

#### v2 Future (When You Need It)

* **Optional PostgreSQL** for performance at scale
* **Files remain source of truth** - Database is just an index
* **Seamless migration** - No data conversion needed
* **Enterprise features** - Cross-repo dashboards, real-time, analytics

This approach ensures teams can start using GAIT today while preserving the option to scale tomorrow, making it truly revolutionary for modern, AI-assisted development workflows.

***

*Version 2.1 - File-First Architecture*\
*Updated: August 2025*\
*Philosophy: Start simple, scale gracefully*


## Agents & Registry

Agents capture reusable AI personas that can be invoked from the CLI, terminal sessions, and the autonomous job scheduler. Each agent is backed by a markdown document in `.nut/agents/` with YAML frontmatter describing its capabilities, color, and the MCP servers (tools) it can access.

The Agents page provides a streamlined interface for browsing and managing your agent registry. Cards are fully clickable with hover states for easy navigation, and each agent's detail page includes quick actions for editing or launching sessions.

### Configure MCP Servers First

Before assigning tools to an agent, register the MCP servers that should be discoverable:

1. Navigate to **Settings → MCP Servers** in the web app (`/settings/mcp`).
2. Add or edit entries. Each server lives under the `mcpServers` key inside `.nut/mcp/config.json`.
3. Ensure `enabled: true` for any server that should appear in the agent picker.

Example configuration:

```json
{
  "mcpServers": {
    "playwright": {
      "command": "npx",
      "args": ["@playwright/mcp@latest"],
      "enabled": true
    },
    "firecrawl-mcp": {
      "command": "npx",
      "args": ["-y", "firecrawl-mcp"],
      "enabled": true,
      "env": {
        "FIRECRAWL_API_KEY": "..."
      }
    }
  }
}
```

Only enabled servers are surfaced in the agent UI. Removing or disabling a server automatically prunes it from any agent that referenced it.

### Creating an Agent in the UI

1. Open **Agents → Create New** (`/agents/new`).
2. Complete the required fields: `Name` (used for the filename) and `Description`.
3. In **Tools (Optional)** the app now lists MCP servers discovered from the config above. Select the servers the agent should be allowed to invoke. Leave everything unchecked to inherit all available servers at runtime.
4. (Optional) Provide detailed system instructions in *Agent Instructions*.
5. Submit the form. The API persists a new markdown file in `.nut/agents/`.

The stored document uses array-based frontmatter for tools:

```yaml
---
name: playwright-runner
description: Runs browser-based regression suites via Playwright MCP
color: cyan
tools:
  - playwright
  - firecrawl-mcp
---
You are a QA specialist...
```

Historically, tools were saved as comma-delimited strings. The backend now normalises old documents into arrays when they are read or rewritten, so downstream consumers always receive `string[]` metadata.

### Editing an Agent

1. Click any agent card to view its details, then click the **Edit** button in the top right
2. The MCP server list is dynamically refreshed from the config file. Disconnected or disabled servers appear unchecked and cannot be re-selected until they are re-enabled.
3. Removing a server from the configuration causes the agent editor to drop that selection on save, keeping the registry aligned with the live tool inventory.

The edit page maintains the same clean layout as other agent pages, with action buttons consistently placed in the top right for easy access.

### CLI Workflows

The `nut agent create` & `nut agent update` commands accept comma-separated `--tools` flags. The core storage layer converts those values into arrays, so the CLI coexists with the new UI.

```bash
nut agent create "playwright-runner" "Runs Playwright checks" \
  --tools "playwright,firecrawl-mcp"
```

### Launching Agent Sessions

Agents can be launched directly from the Agents page for quick, focused work sessions:

1. Navigate to **Agents** (`/agents`) and browse your agent registry
2. Click any agent card to view its details
3. Click **Prepare Agent** in the Agent Actions section
4. This opens a dedicated terminal session where you can configure:
   * Which CLI agent to use (Claude Code, Codex, or Gemini)
   * MCP servers (pre-populated from the agent's tool list)
   * Additional agents to include
   * Custom instructions for this specific session
   * Automation preferences

Agent sessions use minimal base instructions, allowing the agent's own content and your custom instructions to drive the workflow. This makes them ideal for specialized tasks, experimentation, or working with domain-specific agents.

### How Agents Are Used

* **Direct launch ("Prepare Agent")**: Click the Prepare Agent button on any agent's detail page to start a focused session. The agent is automatically selected and its tools are pre-configured. Agent sessions appear in the Code section for easy tracking.
* **Change proposal workflows**: Select agents in the "Configure Coding Agent" modal when working on a change proposal. Agent instructions supplement the structured change proposal workflow.
* **Scheduler jobs**: The job runner respects the agent metadata and handles devcontainer constraints by prefixing Claude invocations with `IS_SANDBOX=1` and wrapping Codex with `script(1)` when running as root.
* **Programmatic access**: `GET /api/v1/agents` returns agent metadata with `tools: string[]`, ensuring automations, the sidebar, and any future integrations see a consistent shape.

### Troubleshooting

* If a server is missing from the picker, confirm it is present and `enabled` in `.nut/mcp/config.json` and that the API has permission to read the file.
* When working in devcontainers, make sure CLI binaries (`claude`, `codex`, `gemini`) are on `$PATH`; the scheduler performs a `command -v` check before executing a job.
* Legacy agents still storing `tools` as a comma-separated string will be rewritten to the new array form on the next update, or you can manually run them through the editor to update immediately.


## API Reference

Complete reference for all Coconut API endpoints. All endpoints follow RESTful conventions and return JSON responses with consistent error handling.

### Base URL

* **Development**: `http://localhost:3001`
* **Production**: Your deployed instance URL

### Authentication

Currently, no authentication is required for API endpoints. Future versions will include API key authentication.

### Response Format

All endpoints return responses in the following format:

```json
{
  "success": true,
  "data": { /* Response data */ },
  "error": { /* Error details if success: false */ }
}
```

### Error Handling

When errors occur, endpoints return appropriate HTTP status codes with error details:

```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message"
  }
}
```

### Endpoints

#### Proposals API

Manage change proposals stored as markdown files in `.gait/proposals/`.

##### List Proposals

```http
GET /api/v1/proposals
```

**Query Parameters:**

* `status` (string, optional): Filter by status (`draft`, `proposed`, `in-review`, `approved`, `merged`, `rejected`)
* `author` (string, optional): Filter by author ID
* `priority` (string, optional): Filter by priority (`low`, `medium`, `high`, `critical`)
* `tags` (string, optional): Comma-separated list of tags to filter by
* `q` (string, optional): Search query for fuzzy search across proposal content

**Response:**

```json
{
  "success": true,
  "data": [
    {
      "id": "cp-1234567890",
      "intent": "Add dark mode support",
      "status": "draft",
      "author": {
        "id": "user123",
        "name": "John Doe",
        "email": "john@example.com",
        "role": "engineer",
        "type": "human"
      },
      "metadata": {
        "createdAt": "2024-08-16T10:30:00Z",
        "updatedAt": "2024-08-16T14:45:00Z",
        "tags": ["ui", "theme"],
        "priority": "medium"
      }
    }
  ]
}
```

##### Create Proposal

```http
POST /api/v1/proposals
```

**Request Body:**

```json
{
  "intent": "Brief description of the change",
  "content": "Detailed markdown content",
  "author": {
    "id": "user123",
    "name": "John Doe",
    "email": "john@example.com",
    "role": "engineer",
    "type": "human"
  },
  "status": "draft",
  "metadata": {
    "tags": ["ui", "feature"],
    "priority": "high"
  }
}
```

**Response:** Returns the created proposal with generated ID and timestamps.

##### Get Proposal

```http
GET /api/v1/proposals/:id
```

**Response:** Returns the complete proposal object including full content and metadata.

##### Update Proposal

```http
PATCH /api/v1/proposals/:id
```

**Request Body:** Partial proposal object with fields to update.

**Response:** Returns the updated proposal object.

##### Delete Proposal

```http
DELETE /api/v1/proposals/:id
```

**Response:**

```json
{
  "success": true,
  "message": "Proposal cp-1234567890 deleted successfully"
}
```

#### Agents API

Manage AI agents stored as markdown files in `.gait/agents/`.

##### List Agents

```http
GET /api/v1/agents
```

**Response:**

```json
{
  "success": true,
  "documents": [
    {
      "filename": "code-reviewer.md",
      "title": "Code Reviewer",
      "metadata": {
        "name": "Code Reviewer",
        "description": "Reviews code for best practices",
        "color": "blue",
        "tools": "code-analysis"
      },
      "content": "# Code Reviewer Agent\n\nThis agent..."
    }
  ]
}
```

##### Create Agent

```http
POST /api/v1/agents
```

**Request Body:**

```json
{
  "name": "My Agent",
  "description": "Agent description",
  "content": "Agent system prompt and instructions",
  "metadata": {
    "color": "green",
    "tools": "file-operations"
  }
}
```

##### Get Agent

```http
GET /api/v1/agents/:id
```

##### Update Agent

```http
PUT /api/v1/agents/:id
```

##### Delete Agent

```http
DELETE /api/v1/agents/:id
```

#### Resources API

Manage uploaded files and resources in `.gait/resources/`.

##### List Resources

```http
GET /api/v1/resources
```

**Response:**

```json
{
  "success": true,
  "data": [
    {
      "id": "res-1234567890-abc123",
      "name": "screenshot.png",
      "type": "image/png",
      "size": 102400,
      "uploadedAt": "2024-08-16T10:30:00Z",
      "metadata": {
        "tags": ["ui", "mockup"],
        "description": "Login page mockup"
      },
      "path": "res-1234567890-abc123.png",
      "thumbnailPath": "res-1234567890-abc123_thumb.jpg"
    }
  ]
}
```

##### Upload Resource

```http
POST /api/v1/resources
```

**Content-Type:** `multipart/form-data`

**Form Fields:**

* `file` (file): The file to upload
* `tags` (string, optional): Comma-separated list of tags
* `description` (string, optional): Resource description

**Response:** Returns the created resource metadata.

##### Get Resource

```http
GET /api/v1/resources/:id
```

##### Download Resource

```http
GET /api/v1/resources/:id?download=true
```

##### Get Thumbnail

```http
GET /api/v1/resources/:id/thumbnail
```

##### Update Resource

```http
PUT /api/v1/resources/:id
```

##### Delete Resource

```http
DELETE /api/v1/resources/:id
```

#### Knowledge Management API

Manage knowledge documents in `.gait/context/knowledge/`.

##### List Knowledge Documents

```http
GET /api/v1/context/knowledge
```

**Response:**

```json
{
  "success": true,
  "documents": [
    {
      "filename": "api-patterns.md",
      "title": "API Design Patterns",
      "metadata": {
        "version": "1.0",
        "updated": "2024-08-16",
        "type": "knowledge",
        "category": "api-patterns",
        "tags": ["rest", "authentication"],
        "sources": ["https://example.com/guide"]
      },
      "content": "# API Design Patterns\n\n..."
    }
  ]
}
```

##### Create Knowledge Document

```http
POST /api/v1/context/knowledge
```

**Request Body:**

```json
{
  "title": "Document Title",
  "content": "# Document Title\n\nContent goes here...",
  "metadata": {
    "category": "best-practices",
    "tags": ["coding", "standards"],
    "sources": ["Internal Documentation"]
  }
}
```

##### Get Knowledge Document

```http
GET /api/v1/context/knowledge/:filename
```

##### Update Knowledge Document

```http
PUT /api/v1/context/knowledge/:filename
```

##### Delete Knowledge Document

```http
DELETE /api/v1/context/knowledge/:filename
```

#### Terminal API

Manage terminal sessions with WebSocket support.

##### Get Terminal Sessions

```http
GET /api/v1/terminal/sessions
```

**Query Parameters:**

* `proposalId` (string, optional): Filter sessions by proposal ID

**Response:**

```json
{
  "sessions": [
    {
      "id": "cp-123-1234567890-abc",
      "proposalId": "cp-123",
      "createdAt": "2024-08-16T10:30:00Z",
      "lastActivity": "2024-08-16T10:35:00Z",
      "connected": true
    }
  ]
}
```

##### Create Terminal Session

```http
POST /api/v1/terminal/:proposalId/create
```

**Request Body (Optional):**

```json
{
  "enableLogging": true,
  "startupCommand": "cd /path/to/project && npm install"
}
```

**Response:**

```json
{
  "sessionId": "cp-123-1234567890-abc",
  "proposalId": "cp-123",
  "createdAt": "2024-08-16T10:30:00Z"
}
```

##### Destroy Terminal Session

```http
POST /api/v1/terminal/:proposalId/destroy
```

**Response:**

```json
{
  "success": true,
  "message": "Terminal session destroyed"
}
```

##### Resize Terminal

```http
POST /api/v1/terminal/:proposalId/resize
```

**Request Body:**

```json
{
  "cols": 80,
  "rows": 24
}
```

##### Terminal WebSocket

```
WS /api/v1/terminal/ws
```

Provides real-time terminal I/O communication.

#### AI Integration API

Interface with AI models for assistance and automation.

##### AI Chat

```http
POST /api/v1/ai
```

**Request Body:**

```json
{
  "message": "Your question or request",
  "history": [
    {
      "role": "user",
      "content": "Previous message"
    },
    {
      "role": "assistant", 
      "content": "Previous response"
    }
  ],
  "model": "anthropic/claude-sonnet-4",
  "context": "proposals",
  "contextContent": "Additional context data",
  "agentPersona": "You are a code review expert...",
  "maxTokens": 2000,
  "enableTools": true
}
```

**Response:**

```json
{
  "response": "AI generated response",
  "toolCalls": [
    {
      "id": "call_123",
      "function": {
        "name": "change_proposals",
        "arguments": "{\"operation\": \"list\"}"
      }
    }
  ],
  "toolResults": [
    {
      "tool_call_id": "call_123",
      "content": "{\"success\": true, \"data\": [...]}"
    }
  ]
}
```

#### Chat History API

Manage conversation history stored in `.gait/chats/`.

##### List Chats

```http
GET /api/v1/chats
```

**Response:**

```json
{
  "chats": [
    {
      "id": "chat-1234567890-abc123",
      "title": "How to implement dark mode?",
      "messages": [
        {
          "role": "user",
          "content": "How do I add dark mode?",
          "timestamp": "2024-08-16T10:30:00Z"
        }
      ],
      "model": "anthropic/claude-sonnet-4",
      "context": {
        "type": "proposals",
        "content": "...",
        "displayId": "cp-123"
      },
      "createdAt": "2024-08-16T10:30:00Z",
      "updatedAt": "2024-08-16T10:35:00Z"
    }
  ]
}
```

##### Create Chat

```http
POST /api/v1/chats
```

**Request Body:**

```json
{
  "title": "Chat Title",
  "messages": [
    {
      "role": "user",
      "content": "Your message",
      "timestamp": "2024-08-16T10:30:00Z"
    }
  ],
  "model": "anthropic/claude-sonnet-4",
  "context": {
    "type": "proposals",
    "content": "context data"
  }
}
```

##### Get Chat

```http
GET /api/v1/chats/:id
```

##### Update Chat

```http
PUT /api/v1/chats/:id
```

##### Delete Chat

```http
DELETE /api/v1/chats/:id
```

#### Configuration API

Access GAIT configuration from `.gait/config.json`.

##### Get Configuration

```http
GET /api/v1/config
```

**Response:**

```json
{
  "success": true,
  "data": {
    "version": "1.0",
    "features": {
      "ai": true,
      "terminal": true
    }
  }
}
```

#### MCP (Model Context Protocol) API

Interface with MCP servers and execute tools.

##### List MCP Servers

```http
GET /api/v1/mcp
```

**Response:**

```json
{
  "success": true,
  "servers": ["filesystem", "web"],
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": ["@modelcontextprotocol/server-filesystem"]
    }
  },
  "tools": {
    "proposals": {
      "name": "change_proposals",
      "description": "Manage change proposals"
    },
    "listProposals": {
      "name": "list_proposals", 
      "description": "List change proposals"
    }
  }
}
```

##### Execute Tool

```http
POST /api/v1/mcp/execute
```

**Request Body:**

```json
{
  "tool": "change_proposals",
  "arguments": {
    "operation": "list",
    "filters": {
      "status": "draft"
    }
  }
}
```

#### Context APIs

Access project architecture and context files.

##### Get Architecture

```http
GET /api/v1/context/architecture
```

Returns the content of `.gait/context/architecture.md`.

##### Get Project Context

```http
GET /api/v1/context/project
```

Returns the content of `.gait/context/project.md`.

#### User Settings API

Manage user preferences and settings.

##### Get User Settings

```http
GET /api/v1/user/settings
```

##### Update User Settings

```http
PUT /api/v1/user/settings
```

##### Get User Info

```http
GET /api/v1/user
```

### Rate Limits

Currently no rate limits are enforced. This may change in future versions.

### Versioning

The API uses semantic versioning. The current version is `v1`. Breaking changes will increment the major version number.

### SDK Support

TypeScript SDK is available in the `@lovelybunch/types` package for type-safe API interactions.


## Authentication

Coconut includes an optional, file-based authentication system for team deployments. Authentication is **disabled by default** and completely opt-in.

### Design Philosophy

* **Opt-in by default** - Works without authentication for local/solo use
* **File-based storage** - No database required, auth config lives in `.nut/auth.json`
* **Email whitelist model** - Admins pre-configure allowed users
* **Role-based access** - Support for multiple team roles
* **Non-breaking** - Existing projects work identically with or without auth

### Quick Start

#### Initialize Authentication

```bash
# From your project root
nut auth init
```

You'll be prompted for:

* Admin email address
* Admin name
* Admin password (minimum 8 characters)

This creates `.nut/auth.json` with `enabled: false` by default.

#### Enable Authentication

```bash
nut auth toggle
```

Confirms the action and enables authentication. **Important:** This regenerates the session secret, invalidating all existing sessions.

#### Add Users

```bash
nut auth add-user
```

You'll be prompted for:

* Email address (must be whitelisted before they can register)
* Full name
* Role (admin, manager, engineer, designer, product\_manager, viewer)

#### List Users

```bash
nut auth list-users
```

Shows all configured users with their roles and registration status.

### Web UI Management

#### Settings > Authentication

Access at `/settings/authentication` to:

* **Toggle authentication** on/off
* **Toggle self-registration** - Allow whitelisted users to self-register
* **Manage users** - Add, update roles, reset passwords, delete users
* **Configure session settings** - Expiration time, cookie settings

**Note:** This page is accessible when auth is disabled (for setup) or when logged in as an admin.

#### Settings > API Keys

Access at `/settings/api-keys` to:

* **Create API keys** for programmatic access (CI/CD, automation)
* **Set expiration dates** - 30 days, 90 days, 1 year, or never
* **View active keys** - See masked previews, creation dates, last used
* **Delete keys** - Revoke access immediately

**Security:** API keys are only shown once on creation. Store them securely.

### Authentication Methods

#### User Sessions (JWT)

* Email/password authentication
* JWT tokens stored in HTTP-only cookies
* Default expiration: 7 days (configurable)
* Automatic token refresh on requests

**Login Flow:**

1. Visit `/login` when auth is enabled
2. Enter email and password
3. Optionally register if email is whitelisted and self-registration is enabled
4. Redirected to dashboard on success

#### API Keys

For programmatic access (CI/CD, scripts, automation):

```bash
# Include in requests
curl -H "X-API-Key: your-key-here" \
  http://localhost:3000/api/v1/proposals
```

**Features:**

* Separate from user sessions
* Scoped permissions (future)
* Expiration dates
* Last used tracking
* One-time display on creation

### Role-Based Access Control

#### Available Roles

| Role                 | Description        | Access Level                          |
| -------------------- | ------------------ | ------------------------------------- |
| **admin**            | Full system access | Can manage auth, users, all resources |
| **manager**          | Team management    | Can manage proposals, users (limited) |
| **engineer**         | Developer access   | Can create/edit proposals, code       |
| **designer**         | Design access      | Can create/edit proposals, resources  |
| **product\_manager** | Product access     | Can create/edit proposals, specs      |
| **viewer**           | Read-only access   | Can view but not modify               |

#### Admin-Only Features

* Authentication settings management
* User management (add, remove, reset passwords)
* API key management
* System configuration

### Security Considerations

#### Password Security

* Bcrypt hashing with 10 salt rounds
* Minimum 8 characters required
* Admin can reset user passwords

#### Token Security

* JWT tokens signed with auto-generated secret
* HTTP-only cookies prevent XSS attacks
* SameSite attribute prevents CSRF
* Configurable expiration (default 7 days)

#### API Key Security

* Keys hashed with bcrypt before storage
* Only shown once on creation
* Tracked: last used timestamp, expiration date
* Can be revoked immediately

#### Session Invalidation

When toggling authentication on/off, all sessions are automatically invalidated:

* Session secret is regenerated
* All users must re-authenticate
* Ensures clean security state

#### File Permissions

**Important:** Add `.nut/auth.json` to your `.gitignore`:

```bash
echo ".nut/auth.json" >> .gitignore
```

This file contains:

* Password hashes
* Session secrets
* API key hashes

### Production Deployment

#### Required for Internet Use

1. **HTTPS/TLS** - Absolutely required
   * Without HTTPS, passwords and tokens are sent in cleartext
   * Use nginx/Caddy with SSL cert, or platform like Render/Railway

2. **Enable Secure Cookies** - Set in auth.json:
   ```json
   "session": {
     "secure": true,
     "cookieName": "nut-session",
     "expiresIn": "7d"
   }
   ```

3. **Environment Variables** - For production secret:
   ```bash
   export NUT_SESSION_SECRET="your-long-random-secret-here"
   ```

4. **CORS Configuration** - Restrict allowed origins in production

#### Recommended

* Rate limiting for login attempts
* Account lockout after failed attempts
* Audit logging for security events
* Regular session secret rotation
* Monitor failed authentication attempts

### Configuration File Structure

`.nut/auth.json` (created by `nut auth init`):

```json
{
  "version": "1.0",
  "enabled": false,
  "allowRegistration": true,
  "providers": {
    "local": {
      "enabled": true,
      "users": [
        {
          "id": "user-123",
          "email": "admin@example.com",
          "name": "Admin User",
          "role": "admin",
          "passwordHash": "$2b$10$...",
          "registered": true,
          "createdAt": "2025-01-15T10:00:00Z",
          "updatedAt": "2025-01-15T10:00:00Z"
        }
      ]
    },
    "oauth": {
      "google": {
        "enabled": false,
        "clientId": "",
        "clientSecret": "",
        "callbackUrl": ""
      }
    }
  },
  "session": {
    "secret": "auto-generated-secret",
    "expiresIn": "7d",
    "cookieName": "nut-session",
    "secure": false
  },
  "apiKeys": []
}
```

### Troubleshooting

#### Can't access after enabling auth

**Solution:** Clear your browser cookies and log in again. Or run `nut auth toggle` twice to regenerate sessions.

#### 403 Forbidden on auth routes

**Check:**

* Are you logged in?
* Is your user role `admin`?
* Try logging out and back in

#### Sessions not persisting

**Check:**

* Is HTTPS enabled in production?
* Are cookies enabled in your browser?
* Check `secure` flag in `auth.json` matches your deployment (true for HTTPS, false for HTTP)

#### Forgot admin password

**Solution:** Use CLI to reset:

1. Edit `.nut/auth.json` directly to add a new admin user
2. Or delete `.nut/auth.json` and run `nut auth init` again

### API Reference

#### Authentication Endpoints

```
POST   /api/v1/auth/login              # Email/password login
POST   /api/v1/auth/register           # Self-registration (if enabled)
POST   /api/v1/auth/logout             # Clear session
GET    /api/v1/auth/me                 # Get current user
POST   /api/v1/auth/change-password    # Change password
GET    /api/v1/auth/status             # Check if auth enabled (public)
```

#### Admin Endpoints (requires admin role)

```
GET    /api/v1/auth-settings           # Get auth config
PUT    /api/v1/auth-settings           # Update auth settings
POST   /api/v1/auth-settings/users     # Add user to whitelist
PUT    /api/v1/auth-settings/users/:id # Update user
POST   /api/v1/auth-settings/users/:id/reset-password  # Reset password
DELETE /api/v1/auth-settings/users/:id # Remove user
```

#### API Key Endpoints

```
GET    /api/v1/api-keys                # List API keys
POST   /api/v1/api-keys                # Create API key
DELETE /api/v1/api-keys/:id            # Delete API key
```

### Future Enhancements

**Planned for v2:**

* OAuth providers (Google, GitHub, GitLab, Azure AD)
* SAML/SSO for enterprise
* Two-factor authentication (TOTP)
* Password reset via email
* WebSocket authentication
* Audit logging
* Session management UI
* Rate limiting
* Account lockout
* IP whitelisting

### Related Documentation

* [CLI Reference](/cli) - Command-line authentication management
* [API Reference](/api) - Authentication API endpoints
* [Security Best Practices](/contributing#security) - Secure deployment guidelines


## CLI (aka `nut`)

### Initialize a new Coconut

From the root of your project where you want to setup your `.nut`.

```bash
nut init
```

### Change Proposals

#### Creating and Managing Proposals

```bash
# List all proposals
nut list

# Create a new proposal
nut propose "Add user authentication feature"

# View proposal details
nut show cp-1234567890
```

#### Implementing Proposals with AI

The `code` command starts an AI coding session to implement a proposal. The session runs in the background and is visible via the web interface.

```bash
# Basic implementation
nut code cp-1234567890

# With autonomous mode (skips permissions)
nut code cp-1234567890 --auto

# With custom instructions
nut code cp-1234567890 --custom-instructions "Focus on type safety and error handling"

# Create a new git worktree for this proposal
nut code cp-1234567890 --new-worktree

# Add a custom suffix to the generated worktree branch
nut code cp-1234567890 --new-worktree --worktree-suffix 654321

# Use a different AI model
nut code cp-1234567890 --model gemini

# Combine multiple flags
nut code cp-1234567890 --autonomous --new-worktree --custom-instructions "Use modern React patterns"
```

##### Code Command Options

| Flag                           | Description                                                                                 | Example                                       |
| ------------------------------ | ------------------------------------------------------------------------------------------- | --------------------------------------------- |
| `--model <model>`              | AI model to use (`claude`, `gemini`, `codex`)                                               | `--model gemini`                              |
| `--api <url>`                  | API base URL                                                                                | `--api http://localhost:3001`                 |
| `--autonomous`                 | Skip permission prompts (dangerous mode)                                                    | `--autonomous`                                |
| `--auto`                       | Alias for `--autonomous`                                                                    | `--auto`                                      |
| `--custom-instructions <text>` | Additional instructions for the AI                                                          | `--custom-instructions "Use TypeScript"`      |
| `--new-worktree`               | Create a new git worktree for the session (CLI switches the terminal into it automatically) | `--new-worktree`                              |
| `--worktree-suffix <suffix>`   | Append a suffix to the generated worktree branch name                                       | `--worktree-suffix 654321`                    |
| `--worktree-branch <name>`     | Override the generated worktree branch entirely                                             | `--worktree-branch feat/cp-1234567890-654321` |

> When `--autonomous`/`--auto` is used, the CLI automatically applies the correct bypass flag for the selected agent (e.g. `--yolo` for Gemini, `--dangerously-bypass-approvals-and-sandbox` for Codex).

##### How It Works

1. **Health Check**: Verifies the Coconut API is running
2. **Session Creation**: Creates a terminal session via the API
3. **Worktree Setup**: Optionally creates a new git worktree (auto-suffixing the branch if a name collision is detected and switching the terminal session into that worktree)
4. **MCP Integration**: Loads available MCP servers and agents
5. **Command Execution**: Sends the AI command to the terminal session via WebSocket
6. **Background Execution**: Runs headlessly while remaining visible in the web UI

##### Monitoring Sessions

```bash
# The command provides a web UI link for monitoring
nut code cp-1234567890
# 📱 You can monitor progress at: http://localhost:3000/terminal/cp-001

# Press Ctrl+C to stop monitoring (session continues running)
# 💡 Session continues running at: http://localhost:3000/terminal/cp-001
```

##### Session Integration

* **Web UI Visibility**: All sessions appear in the web interface
* **Real-time Updates**: Watch AI progress in the browser
* **Proposal Updates**: AI automatically updates proposal files when complete
* **Persistent Sessions**: Sessions continue running even if CLI disconnects
* **Future Monitoring**: Upcoming `nut monitor` command will show all active sessions

#### Web Interface

```bash
nut serve
```

On a remote server or devcontainer you can start with the following to make it accessible remotely:

```bash
nut serve --port=3002 --host=0.0.0.0
```

To prevent automatic browser opening (useful for SSH environments):

```bash
nut serve --no-open
```

##### Serve Command Options

| Flag            | Description                       | Example          |
| --------------- | --------------------------------- | ---------------- |
| `--port <port>` | Port to run the server on         | `--port 3002`    |
| `--host <host>` | Host to bind the server to        | `--host 0.0.0.0` |
| `--no-open`     | Prevent automatic browser opening | `--no-open`      |

### Configuration

```bash
# Manage global configuration
nut config
```

### Schema Reference Templates

Use the schema command to regenerate the reference files in `.nut/.schema` if they drift from the canonical templates or after upgrading Coconut.

```bash
# Refresh all schema templates from packages/shared/system-prompts/schema
nut schema refresh
```

### Agent Management

```bash
# List available agents
nut agent

# Agents are automatically loaded when using the code command
```

### Help

```bash
# General help
nut --help

# Command-specific help
nut code --help
nut propose --help
nut serve --help
```


## Contributing

```
cursor --folder-uri "vscode-remote://ssh-remote+bluer-meerkat/home/deployer/developer/coconut-dev"
cursor --folder-uri vscode-remote://ssh-remote+<hostname>/<folder_path>
```

### Development & Version Management

#### Local Development

For local development with hot reload across all packages:

```bash
# Start all packages in watch mode
pnpm run dev

# Or start individual packages
cd packages/api && pnpm run dev      # API server with tsx watch
cd packages/frontend && pnpm run dev # Frontend with Vite HMR
cd packages/cli && pnpm run dev      # CLI with TypeScript watch
```

#### Testing the CLI

```
node ../coconut/packages/cli/dist/index.js propose “change the title to ‘John’”
node ../coconut/packages/cli/dist/index.js code cp-002 --autonomous --new-worktree --model claude
node ./packages/cli/dist/index.js schema refresh
```

#### Version Bumping

The project includes automated scripts for version management:

```bash
# Bump patch version (1.0.12 → 1.0.13)
pnpm run version:bump:patch

# Bump minor version (1.0.12 → 1.1.0)
pnpm run version:bump:minor

# Bump major version (1.0.12 → 2.0.0)
pnpm run version:bump:major

# Or specify type manually
pnpm run version:bump minor
```

**What the version bump script does:**

* Updates all package versions in dependency order
* Updates cross-package dependencies automatically
* Maintains proper version relationships between packages
* Updates root package.json version

#### Publishing Packages

After bumping versions, publish all packages to npm:

```bash
# Build and publish all packages in correct order
pnpm run publish:all

# Or do everything in one command
pnpm run release  # Bumps patch version + publishes
```

**Publishing order (dependencies first):**

1. `@lovelybunch/types` - Shared TypeScript types
2. `@lovelybunch/core` - Core business logic
3. `@lovelybunch/api` - Hono API server + bundled frontend
4. `@lovelybunch/cli` - Command-line interface
5. `coconuts` - Global CLI wrapper

**What the publish script does:**

* Builds all packages with `turbo build`
* Bundles frontend with API package
* Publishes packages in dependency order
* Provides clear success/failure feedback

#### Release Workflow

Complete release process:

```bash
# 1. Bump versions (patch by default)
pnpm run version:bump:patch

# 2. Review changes
git diff

# 3. Build and publish
pnpm run publish:all

# 4. Commit changes
git add .
git commit -m "chore: bump versions to patch"

# 5. Create git tag (optional)
git tag v1.0.13
git push origin main --tags
```

#### Package Structure

```
packages/
├── types/          # Shared TypeScript types
├── core/           # Core business logic & storage
├── api/            # Hono API server + bundled frontend
├── cli/            # Command-line interface
├── frontend/       # React frontend (bundled into API)
└── coconuts/       # Global CLI wrapper (nut command)
```

**Note:** The `frontend` package is not published separately as it's bundled into the `api` package for distribution.


## Devcontainer Setup

### Overview

[Devcontainers](https://containers.dev) are a feature of VS Code, Cursor, and other supported IDEs that enable you to create a consistent and secure development environment using containers. They run in an isolated environment, making them particularly well-suited for coding agents and AI-powered development tools such as [Claude Code](https://www.anthropic.com/claude-code), Google [Gemini CLI](https://cloud.google.com/gemini/docs/codeassist/gemini-cli), or OpenAI's [Codex](https://github.com/openai/codex).

The key advantage of this approach is that you can run development tools in complete isolation with elevated permissions (using flags like YOLO modes like Claude Code's [--dangerously-skip-permissions](https://docs.anthropic.com/en/docs/claude-code/cli-reference)) without compromising your host system's security.

### Devcontainer CLI install

```
npm install -g @devcontainers/cli
```

### Devcontainer Setup

:::info
Make sure you are inside your project folder.
:::

Download the Coconut devcontainer:

```
curl -fsSL https://raw.githubusercontent.com/lovelybunch/coconut-init/main/.devcontainer/setup-in-project.sh | bash
```

Build the underlying container:

```
devcontainer build --workspace-folder .
```

Start the devcontainer:

```
devcontainer up --workspace-folder .
```

List all devcontainers:

```
docker ps --filter "label=devcontainer.local_folder"
```

Remmove all devcontainers (remember the code is outside the containers so won't be lost):

```
docker ps -aq --filter "label=devcontainer.local_folder" | xargs docker rm -f
```

### Rebuilding Container

```
devcontainer build --workspace-folder .
docker ps --filter "label=devcontainer.local_folder"
docker rm -f <container-name>
devcontainer up --workspace-folder
docker exec -it <container-name> bash
```

### Long running `nut serve` from devcontainer

Connect into the container via the above (if it's already running you'll need the containers name and the last step to connect) and then run the following on the correct port. This will start the coconut service in the background.

```
nohup nut serve --host=0.0.0.0 --port=3020 > /tmp/nut.log 2>&1 & disown
```

Note it can be built without cache (`devcontainer build --workspace-folder . --no-cache`).


import { HomePage } from 'vocs/components'

<HomePage.Root>
  <HomePage.Logo />

  <HomePage.Tagline>My Awesome Docs</HomePage.Tagline>

  <HomePage.InstallPackage name="vocs" type="init" />

  <HomePage.Description>This is a description of my documentation website.</HomePage.Description>

  <HomePage.Buttons>
    <HomePage.Button href="/getting-started" variant="accent">Get started</HomePage.Button>
    <HomePage.Button href="https://github.com/wevm/vocs">GitHub</HomePage.Button>
  </HomePage.Buttons>
</HomePage.Root>


## Getting started

### Dependencies

* Node.js 18+
* node-pty

### Installation

```bash
npm install -g coconuts
```

From the root of your project where you want to setup your `.nut`.

```bash
nut init
```

Start the web interface.

```bash
nut serve
```

And you should now see the following:

![Coconut Web UI](./images/screenshot.png)

### Ubuntu

The following walks through a fresh install on an Ubuntu system.

Start with installing NVM and Node `v22`:

```
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash

export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] && printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" # This loads nvm

nvm install 22
```

Install the various build dependencies to install `node-pty` (and `git`)

```
sudo apt install -y build-essential python3 make g++ git
npm install node-pty
```


## Git Management

Coconut provides comprehensive git operations through an integrated UI and API, enabling you to manage branches, commits, worktrees, and remote synchronization without leaving your development environment.

### Overview

The Git Management system in Coconut offers:

* **Repository Status** - Real-time view of your current branch, uncommitted changes, and sync status
* **Branch Management** - Create, switch, merge, and delete branches with visual feedback
* **Commit Operations** - Commit changes with smart guidance for default branches
* **Worktrees** - Work on multiple branches simultaneously in separate directories
* **Remote Sync** - Push and pull changes with authentication status monitoring
* **Settings** - Configure worktree paths and manage credentials

All git operations are designed to work non-interactively with proper timeout protection to prevent UI hangs.

### Repository Status

The Repository Status section provides a real-time overview of your working directory:

#### Current Branch Information

* Branch name with visual indicator
* Commits ahead of remote (with **unpushed indicator** when > 0)
* Commits behind remote
* Upstream tracking branch

#### Uncommitted Changes

* List of modified, added, deleted, and untracked files
* Status indicators for each file (M, A, D, U, etc.)
* Quick overview of what needs to be committed

#### Status Indicators

When you have commits that haven't been pushed to the remote, Coconut highlights them with:

* Amber background highlighting on the ahead count
* "unpushed" label instead of "ahead"
* Visual prominence to remind you to push your changes

### Branch Management

Coconut provides a complete branch workflow through the Branches section.

#### Creating Branches

1. Select a **base branch** to branch from (typically `main` or your current branch)
2. Enter a **branch name** (e.g., `feature/new-feature`)
3. Click **Create Branch**

The branch is created locally and you can switch to it when ready.

#### Switching Branches

Click the **Switch** button next to any branch to check it out. Coconut will:

* Switch your working directory to the selected branch
* Update the repository status
* Refresh all git-related UI elements

#### Merging Branches

Merge any branch into your current branch with three strategies:

* **Merge commit** (default) - Creates a merge commit preserving full history
* **Squash & merge** - Combines all commits into a single commit
* **Rebase & merge** - Replays commits on top of the current branch

Select your preferred strategy in the merge dropdown, then click **Merge** next to the branch you want to merge.

#### Deleting Branches

Remove local branches that are no longer needed by clicking the **Delete** button. This performs a force delete (`git branch -D`) to remove the branch even if it hasn't been merged.

**Note:** You cannot delete the currently active branch.

### Commit Changes

The Commit Changes section lets you create commits with smart guidance.

#### Basic Commits

1. Make changes to your files
2. Enter a commit message describing your changes
3. Click **Commit**

By default, all uncommitted changes are included. The commit is created on your current branch.

#### Default Branch Protection

When you're on a default branch (`main` or `master`), Coconut displays a warning and suggests creating a feature branch first. This encourages best practices:

* Keeps your default branch stable and deployable
* Makes it easier to review and test changes
* Enables working on multiple features simultaneously
* Simplifies collaboration with your team

You can still commit directly to the default branch if needed by clicking **"Commit to main Anyway"** in the suggestion dialog.

#### Branch Creation Suggestion

If you choose to create a branch from the suggestion dialog:

1. Enter a new branch name
2. Click **Create Branch & Switch**
3. Coconut creates the branch from your current branch
4. Automatically switches to the new branch
5. You can then commit your changes to the feature branch

### Worktrees

Git worktrees allow you to check out multiple branches simultaneously in different directories. This is perfect for:

* Working on multiple features in parallel
* Testing changes without switching branches
* Running builds on one branch while developing on another
* Reviewing PRs while keeping your current work intact

#### Creating Worktrees

1. Enter a branch name (existing or new)
2. Click **Create Worktree**

Coconut creates the worktree in the configured location (default: `../worktrees/` relative to your project root).

#### Working with Worktrees

Each worktree:

* Has its own working directory
* Can be pushed/pulled independently
* Shows the associated branch name
* Displays the full filesystem path

#### Worktree Operations

* **Pull** - Fetch and merge/rebase changes from remote
* **Push** - Push commits to remote repository
* **Remove** - Delete the worktree directory (prompts for confirmation)

#### Configuring Worktree Location

Navigate to **Settings → Git** to configure where worktrees are created. The path is relative to your project root. We recommend keeping worktrees outside the repository (e.g., `../worktrees`).

### Push and Pull

#### Top-Right Actions

The Git Management page includes quick Push and Pull buttons in the top-right corner:

* **Pull** - Fetch and merge/rebase changes from remote
  * Choose strategy: Rebase (default), Merge, or Fast-forward only
* **Push** - Push your current branch to the remote
  * Shows spinner while pushing
  * Displays error if authentication fails

Both operations include:

* Loading spinners during execution
* Success/error toast notifications
* Automatic authentication dialog on auth failures

#### Pull Strategies

* **Rebase** (recommended) - Replays your commits on top of remote changes for linear history
* **Merge** - Creates a merge commit when integrating remote changes
* **Fast-forward only** - Only succeeds if your branch can be fast-forwarded (no merge needed)

Configure the default strategy in the pull dropdown on the Repository Status section.

### Git Authentication

Coconut requires proper git authentication to push and pull changes to remote repositories. This section covers how to configure authentication for GitHub, GitLab, and other git providers.

#### Why Authentication is Required

When you use Coconut's Git features, the underlying git commands need to authenticate with your remote repository. Without proper authentication, operations will fail with error messages like:

* `terminal prompts disabled`
* `could not read Username`
* `Authentication required`

Coconut runs git commands non-interactively (`GIT_TERMINAL_PROMPT=0`) to prevent the UI from hanging, so credentials must be configured ahead of time.

#### Authentication Methods

Coconut supports all standard git authentication methods. Choose the one that best fits your workflow:

##### Method 1: SSH Keys (Recommended)

SSH keys are the most secure and convenient method for git authentication. They work seamlessly with Coconut's automated git operations.

**Setup SSH Keys:**

1. **Generate a new SSH key:**

```bash
ssh-keygen -t ed25519 -C "your_email@example.com"
```

When prompted, press Enter to save the key to the default location (`~/.ssh/id_ed25519`).

2. **Start the SSH agent:**

```bash
eval "$(ssh-agent -s)"
```

3. **Add your SSH key to the agent:**

```bash
ssh-add ~/.ssh/id_ed25519
```

4. **Copy your public key:**

```bash
# macOS
pbcopy < ~/.ssh/id_ed25519.pub

# Linux
cat ~/.ssh/id_ed25519.pub | xclip -selection clipboard

# Windows (Git Bash)
cat ~/.ssh/id_ed25519.pub | clip
```

5. **Add the key to your git provider:**

* **GitHub**: Settings → SSH and GPG keys → New SSH key
* **GitLab**: Preferences → SSH Keys
* **Bitbucket**: Personal settings → SSH keys

6. **Update your remote URL to use SSH:**

```bash
# Check current remote URL
git remote -v

# If using HTTPS, switch to SSH
git remote set-url origin git@github.com:username/repository.git
```

##### Method 2: Git Credential Manager

Git Credential Manager securely stores your credentials using your operating system's credential store.

**macOS (osxkeychain):**

macOS comes with built-in credential helper support:

```bash
# Check if already configured
git config --get credential.helper

# If not configured, set it up
git config --global credential.helper osxkeychain
```

The next time you push/pull, you'll be prompted for your username and password (or personal access token). These credentials will be stored securely in your macOS Keychain.

**Linux/Windows (Git Credential Manager):**

Install Git Credential Manager for enhanced credential storage:

```bash
# macOS (via Homebrew)
brew install git-credential-manager

# Linux (Debian/Ubuntu)
wget https://github.com/git-ecosystem/git-credential-manager/releases/latest/download/gcm-linux_amd64.deb
sudo dpkg -i gcm-linux_amd64.deb

# Windows (via winget)
winget install Git.Git-Credential-Manager
```

##### Method 3: Personal Access Tokens (HTTPS)

For HTTPS authentication, use a Personal Access Token instead of your password.

**Creating a Personal Access Token:**

**GitHub:**

1. Settings → Developer settings → Personal access tokens → Tokens (classic)
2. Generate new token
3. Select scopes: `repo` (full control of private repositories)
4. Copy the token

**GitLab:**

1. Preferences → Access Tokens
2. Create personal access token
3. Select scopes: `read_repository`, `write_repository`
4. Copy the token

**Option A: Enter Credentials via Coconut UI (Easiest)**

For HTTPS remotes, Coconut provides a convenient UI to enter your credentials:

1. Navigate to **Settings → Git** or click the auth status indicator on the Git page
2. Click **"Enter Credentials"** button
3. Enter your username and personal access token
4. Click **"Save Credentials"**

Coconut will automatically:

* Configure the appropriate credential helper for your OS
* Store credentials securely (macOS Keychain, Windows Credential Manager, etc.)
* Test the authentication

**Option B: Command Line Setup**

When prompted for a password during git operations, use your personal access token instead:

```bash
# Configure git to cache credentials
git config --global credential.helper store

# Next push/pull will prompt for credentials
git push
# Username: your-username
# Password: <paste-your-personal-access-token>
```

**Note:** `credential.helper store` saves credentials in plain text at `~/.git-credentials`. For better security, use Git Credential Manager instead.

#### Checking Authentication Status

Coconut provides built-in tools to verify your git authentication:

**In the UI:**

1. Navigate to **Settings → Git**
2. Check the "Remote Authentication" section
3. Click "Check Status" to verify connectivity

You'll see:

* ✅ **Authenticated**: Your git credentials are properly configured
* ❌ **Not Authenticated**: Authentication setup required

The Git Management page also shows a small authentication badge in the top-left corner that links to Settings.

**Via Command Line:**

Test your authentication manually:

```bash
# Test SSH connection (for SSH method)
ssh -T git@github.com

# Test HTTPS connection (for HTTPS method)
git ls-remote origin HEAD
```

#### Troubleshooting Authentication

##### "terminal prompts disabled" Error

This error occurs when git tries to prompt for credentials but can't because Coconut runs git commands non-interactively.

**Solution:**

* Set up SSH keys (recommended)
* Configure Git Credential Manager
* Use credential helper to cache tokens

##### Authentication Timeout

Coconut times out git operations after 30 seconds to prevent indefinite hangs.

**Solution:**

* Ensure your credentials are properly cached
* Check your network connection
* Verify your remote repository is accessible

##### Push/Pull Fails but Manual Commands Work

If git commands work in your terminal but fail in Coconut, you may have credential helpers that only work interactively.

**Solution:**

* Configure SSH keys (works in all contexts)
* Use Git Credential Manager (persists across sessions)
* Avoid `credential.helper cache` (only works in active terminal sessions)

##### SSH Key Not Found

If you see "Permission denied (publickey)", your SSH key isn't being used.

**Solution:**

```bash
# Verify SSH agent is running
ssh-add -l

# Add your key to the agent
ssh-add ~/.ssh/id_ed25519

# Configure SSH to use your key automatically
cat >> ~/.ssh/config << EOF
Host github.com
  HostName github.com
  User git
  IdentityFile ~/.ssh/id_ed25519
  IdentitiesOnly yes
EOF
```

### Settings

The Git Settings page (**Settings → Git**) provides configuration for git operations.

#### Remote Authentication

* **Authentication Status** - Real-time check of remote connectivity
* **Credential Helper Info** - Shows configured credential helper and origin file
* **Credential Input** - For HTTPS remotes, enter username and token directly
* **Setup Instructions** - Quick reference for SSH keys and credential managers

#### Worktree Location

* **Default Worktree Path** - Configure where new worktrees are created
* **Path Validation** - Ensures paths are relative to project root (security)
* **Quick Presets** - Use recommended path with one click

### Best Practices

1. **Use SSH keys** for the most seamless experience with Coconut
2. **Create feature branches** instead of committing directly to main/master
3. **Commit frequently** with descriptive messages
4. **Push regularly** to back up your work and collaborate with others
5. **Use worktrees** for parallel work on multiple features
6. **Configure merge strategy** based on your team's workflow
7. **Check authentication status** before starting work to avoid errors

### Related Documentation

* [Git Worktrees](https://git-scm.com/docs/git-worktree) - Official git worktree documentation
* [GitHub SSH Documentation](https://docs.github.com/en/authentication/connecting-to-github-with-ssh)
* [GitLab SSH Documentation](https://docs.gitlab.com/ee/user/ssh.html)
* [Git Credential Manager](https://github.com/git-ecosystem/git-credential-manager)

### Need Help?

If you're experiencing git-related issues:

1. Check the error message in the Coconut UI
2. Verify authentication status in **Settings → Git**
3. Run `git config --list` to review your git configuration
4. Test operations manually with git CLI commands
5. Check [GitHub Issues](https://github.com/lovelybunch/coconut/issues) for similar problems


## LLM Setup

### API Key Configuration

Coconut includes an AIAssistant that requires API keys from supported providers. Configure them globally after installation:

#### Interactive Setup (Recommended)

```bash
nut config set-key --interactive
```

This will guide you through:

* Selecting an API provider (OpenRouter, Anthropic, OpenAI, or Google Gemini)
* Entering your API key with format validation
* Providing setup instructions and URLs

#### Direct Setup

```bash
# OpenRouter (recommended - access to multiple models)
nut config set-key -p openrouter -k sk-or-v1-your-key-here

# Or use specific providers
nut config set-key -p anthropic -k sk-ant-your-key-here
nut config set-key -p openai -k sk-your-key-here
nut config set-key -p gemini -k AI-your-key-here
```

#### Getting API Keys

```bash
# Show setup guide for all providers
nut config setup

# Show setup guide for specific provider
nut config setup -p openrouter
```

**Supported Providers:**

* **OpenRouter** - Access multiple AI models through one API ([Get key](https://openrouter.ai/keys))
* **Anthropic** - Direct Claude access ([Get key](https://console.anthropic.com/))
* **OpenAI** - Direct GPT access ([Get key](https://platform.openai.com/api-keys))
* **Google Gemini** - Direct Gemini access ([Get key](https://makersuite.google.com/app/apikey))

#### Managing API Keys

```bash
# List configured keys (masked for security)
nut config list-keys

# View full configuration
nut config show

# Remove a key
nut config remove-key openrouter

# Set default model
nut config set-default model anthropic/claude-sonnet-4
```

**Config Location:**

* macOS: `~/Library/Application Support/coconuts/config.json`
* Linux: `~/.config/coconuts/config.json`
* Windows: `%APPDATA%/coconuts/config.json`


## MCP Tools

The AI Assistant can call MCP tools during a chat to perform actions such as listing and creating Change Proposals. This page summarizes what’s available and how to use it.

### Endpoints

* `GET /api/v1/mcp` — Lists available tools and configured external MCP servers.
* `GET /api/v1/mcp/schema` — Returns JSON Schemas for built‑in tools (`change_proposals`, `list_proposals`).
* `POST /api/v1/mcp/execute` — Executes a tool call with shape `{ tool, arguments }`.

These routes are served by the API package. The AI route (`POST /api/v1/ai`) can enable tools; when the model returns tool\_calls, the server executes them and then asks the model for a final message with tool results included.

### Tools

#### list\_proposals

List proposals (metadata only). Accepts optional filters.

Arguments shape:

```
{
  filters?: {
    status?: 'draft' | 'proposed' | 'in-review' | 'code-complete' | 'approved' | 'merged' | 'rejected',
    priority?: 'low' | 'medium' | 'high' | 'critical',
    tags?: string[],
    search?: string
  }
}
```

#### change\_proposals

Manage proposals: `list | get | create | update | delete`.

Common arguments:

```
{
  operation: 'list' | 'get' | 'create' | 'update' | 'delete',
  id?: string,
  filters?: { ... },
  proposal?: { ... } // for create/update
}
```

Proposal payload (create/update):

```
{
  intent: string,            // required
  content: string,           // required (markdown OK)
  author?: {
    id?: string,
    name?: string,
    email?: string,
    role?: string,
    type?: 'human' | 'agent'
  },
  planSteps?: Array<
    | string
    | {
        id?: string,
        description: string,
        status?: 'pending' | 'in-progress' | 'completed' | 'failed',
        command?: string,
        expectedOutcome?: string
      }
  >,
  metadata?: {
    tags?: string[],
    priority?: 'low' | 'medium' | 'high' | 'critical',
    reviewers?: string[]
  },
  releasePlan?: {
    strategy: 'immediate' | 'gradual' | 'scheduled' | 'gated'
  },
  status?: 'draft' | 'proposed' | 'in-review' | 'code-complete' | 'approved' | 'merged' | 'rejected',
  productSpecRef?: string
}
```

Notes:

* The server normalizes `planSteps` so strings become actionable steps; dates may be ISO strings and are normalized.
* Undefined values are stripped before YAML frontmatter is written.

### Using in the AI Assistant

1. Open the sidebar and select a model that supports tools.
2. Enable “MCP Tools (experimental)” and choose tools as needed.
3. Ask the assistant to “create a change proposal …” and it may call `change_proposals(create)` using the schema above.

If you want deterministic results, construct the exact `proposal` payload per the schema and ask the assistant to call the tool with those arguments.


## Models

### AI Assistant

* ChatGPT 4o
* Claude Sonnet / Opus
* Gemini Pro

### Coding Agents

:::info
Note that at the time of writing with Google's Gemini CLI you get 60 request per minute / 1000 request for free per today
:::

* [Claude Code](https://www.anthropic.com/claude-code)
* [Gemini CLI](https://cloud.google.com/gemini/docs/codeassist/gemini-cli)
* [OpenAI Codex](https://openai.com/codex/)


## Schedule Autonomous Jobs

Coconut ships with a file-first job scheduler that can run Claude, Gemini, or Code CLI agents on an automated cadence. Jobs live in `.nut/jobs/`, so they version with the rest of your project.

### Prerequisites

* Install the CLI you want to run (`claude`, `gemini`, or `codex`) and make sure it is on your `PATH`.
* Launch `nut serve` (or the API package) so the scheduler boots and watches `.nut/jobs/`.

### Creating or Editing Jobs

1. Open the **Schedule** page in the Coconut UI sidebar.
2. Click **New Scheduled Job** (or **Edit** beside an existing job).
3. Provide:
   * **Prompt** – the instruction the agent should run autonomously.
   * **Model** – `Claude`, `Gemini`, or `Code`. The CLI dropdown mirrors the Configure Coding Agent flow.
   * **Cadence** – select days of the week, an hourly interval (minimum one hour), and optional anchor hour.
   * Toggle **Start active** if you want the job to begin immediately.
4. Save. The job is persisted to `.nut/jobs/<id>.md` and scheduled immediately.

The UI shows the most recent run inline and exposes the full history in a modal so you can review summaries without leaving the page. Tags defined in frontmatter render as chips for quick filtering.

### Reliability & Safety

* **CLI guardrails** – Coconut validates the chosen CLI binary with `command -v` before launching a run. Missing binaries result in a clear failure state instead of a crash.
* **Timeouts** – Runs default to a 30 minute maximum. You can override the limit with `COCONUT_JOB_MAX_RUNTIME_MS` if you need longer tasks.
* **Backlog catch-up** – If Coconut restarts after a scheduled window passes, the scheduler immediately executes the missed job once and recalculates the next run.
* **Frontmatter normalization** – Interval schedules are normalized (hours, sorted days, anchor hour) so Markdown diffs stay readable and API payloads remain valid.

### Logs & Artifacts

Each run streams stdout/stderr to `.nut/jobs/logs/<jobId>/<runId>.log`. Summaries are also stored in the job’s Markdown frontmatter (latest 50 entries) for quick reference.

### API Endpoints

| Method   | Path                   | Description                                             |
| -------- | ---------------------- | ------------------------------------------------------- |
| `GET`    | `/api/v1/jobs`         | List scheduled jobs.                                    |
| `POST`   | `/api/v1/jobs`         | Create a job.                                           |
| `PATCH`  | `/api/v1/jobs/:id`     | Update an existing job (interval schedules via UI).     |
| `DELETE` | `/api/v1/jobs/:id`     | Remove a job.                                           |
| `POST`   | `/api/v1/jobs/:id/run` | Trigger a manual run.                                   |
| `GET`    | `/api/v1/jobs/status`  | Inspect scheduler health, next runs, and active timers. |

> Cron schedules can still be authored manually in `.nut/jobs/<id>.md`; the UI currently supports interval-based jobs.

### Troubleshooting

* **Missing CLI binary** – Install the requested CLI globally and confirm `command -v claude` (or `gemini`, `codex`) resolves.
* **Job stuck running** – Check the per-run log in `.nut/jobs/logs/<jobId>/`. Long-running jobs terminate automatically after the configured timeout.
* **No runs after restart** – Ensure `nut serve` is running from the repo root so the scheduler can locate `.nut/`. The `/api/v1/jobs/status` endpoint is useful for verifying timers are active.

With these guardrails, Coconut’s scheduler gives you a safe, repeatable way to automate documentation updates, evidence gathering, or any other repetitive agent task.


## Symlinks

Symlinks allow you to present paths from your project's `.nut` to other areas of either the project or filesystem to allow them to be picked up by IDEs or coding agents.

{/* Test trigger for docs deployment - lockfile fix */}

### Examples

#### Claude Commands

Link Path:

```bash
~/.claude/commands
```

Target Path:

```bash
~/path-to-your-project/.nut/commands
```

#### Claude Agents

TBD

#### Cursor Rules

Link Path:

```bash
~/path-to-your-project/AGENTS.md
```

Target Path:

```bash
~/path-to-your-project/.nut/context/architecture.md
```

...

NOTES

* Also [https://docs.cursor.com/en/context/rules](https://docs.cursor.com/en/context/rules)
* Wired up to `.cursor/rules` or an `AGENTS.md` in project root (although this is just a single file)
* TODO - Cursor uses `.mdc`

### Testing Notes

```
curl -X GET http://localhost:3001/api/v1/symlinks
```

```
curl -X POST http://localhost:3001/api/v1/symlinks \
  -H "Content-Type: application/json" \
  -d '{
    "name": "New Symlink Configuration",
    "description": "Test symlink from ~/.claude/commands to .nut/commands",
    "linkPath": "~/.claude/commands",
    "targetPath": "/Users/bluer/Developer/coconut/.nut/commands",
    "isActive": false
  }'
```


## v1.0.47 - Tropical Moonbars

### Features

* Adds feature template to new proposal page
* Adds initial Coconut documentation
* Devcontainer setup improvements
* Experimental support for MCP servers in AI Advisor
* Ability to configure coding MCP server(s) under settings

### Fixes

* Resolves missing MCP configuration file after `nut init`


## v1.0.48 - Coconut Dipping Dots

### Fixes

* Terminals now remember and show recent output after a page refresh,
  with improved text display reliability
* Fix within the AI Advisor to pull OpenRouter API key from config
* Fixes symlink creation and removal under Settings | Rules
* Renames `.gait` directory to `.nut`
* Tweaks output when running `nut serve`


## v1.0.50 - Glazed Coconut Fritters

### Features

* Full screen view for AI Assistant
* New Code page improves the coding agent UX
* Ability to run jobs from the terminal screen

### Fixes

* MCP servers now working in AI Assistant
* Reducing bundle size
* Increase real estate on chat window by putting dynamic helpers under dropdown (under "Quick prompts")


## v1.0.51 - Island Glow Tarts

### Features

* Adds preview to terminal and code screens

### Fixes

* Resolves issue with the built-in MCP servers when creating proposals


## v1.0.52 - Glistening Ocean Macaroons

### Features

* Ability to add / edit implementation plan details associated with a proposal
* Coding agents now update the assigned change proposal with implementation steps, comments (with suggested future updates), and status upon completion
* Adds a "code complete" status
* New Git settings page allows you to override the default worktree path (which is now a directory outside of the project directory)
* Layout improvements to coding agent configuration
* Experimental worktree support on coding agent screen

### Fixes

* NA


## v1.0.53 - Banana Coconut Scones

### Features

* Renames `nut implement` to `nut code`
* Adds a range of flexibility to such as `nut code cp-001` that starts the selected job which can then be monitored in the Coconut UI

### Fixes

* Resolves CLI commands looking for incorrect directory (rather than `.nut`)


## v1.0.54 - Pandan Coconut Fudge

### Features

* NA

### Fixes

* Ensure all changes to proposals, knowledge, etc made by the coding agents adhere to the schema
* Layout improvements to the Code screen
* Layout improvements to the Knowledge Base screen
* The ability to add content in the AI Assistant chat is disabled after the chat starts


## v1.0.55 - Coconut Fudge Sunday

### Features

* NA

### Fixes

* Hotfix to address schema files not being bundled


## v1.0.56 - Coconut Venus Tarts

### Features

* NA

### Fixes

* Removes `metrics` from `goals` section in `project.md` schema and handling in web UI
* Streamlines display for Project Context and Technical Architecture (with the emphasis shifting to storing more directly in the markdown)
* Updates AI Assistant to be clearer in terms of providing context, etc.


## v1.0.57 - Nutty Coconuts

### Features

* Adds authentication to CLI and Web

### Fixes

* Various UI / UX tweaks
* Fixes `--no-open` flag when using `nut serve` that prevents it from automatically opening the browser


## v1.0.58 - Strawberry Coconut Bursts

### Features

* Adds a heartbeat to the terminal sessions to decrease the chance of timeouts
* Adds streaming support to the AI Assistant
* Updates "Action" buttons that automatically enable the relevant MCP tool
* Adds Scheduling Tool (beta)
* Ability to type ahead (using the "@") to add context in the chat
* Adds streaming responses in the chat

### Fixes

* Various UI / UX tweaks
* Fixes `--no-open` flag when using `nut serve` that prevents it from automatically opening the browser


## v1.0.59 - Triple Chocolate Coconut Delight

### Features

* Adds ability to authenticate with a remote via the Git screen (and updates Git settings).
* Improved Git management (branch handling, committing changes, etc)

### Fixes

* Fixes an issue with the UI freezing when running `git push` (via UI) if not authenticated with `git` in the underlying container / host.


## v1.0.60 - Quadruple Chocolate Coconut Delight

### Features

* Adds add git mamangement functionality

### Fixes

* Performance fixes


## v1.0.61 - Coconut-coladas

### Features

* New utilities section
* Adds activity badges to left side bar

### Fixes

* Performance fixes


## v1.0.62 - Island Cookies

### Features

* Agents are now first-class. Details to follow on what that actually means 🥥

### Fixes

* Fixes flicker / loss of focus on terminals


## v1.0.63 - Coconut Dip

### Features

* Adds simple toolbar to the bottom of the terminal screen
* Visual tweaks to Coding Agent configuration screen

### Fixes

* NA


## Create a proposal

...




## How to configure and start a coding agent

...


## How to use a Vercel template

### Setup

* Go go [https://vercel.com/templates](https://vercel.com/templates) and select a template (e.g. [https://github.com/lovelybunch/template-next-blog](https://github.com/lovelybunch/template-next-blog))
* Clone locally and install the dependencies with `npm install`
* If you're running locally, simply make sure you've got Coconut [installed](https://docs.coconut.dev/getting-started) or run in a [devcontainer](https://docs.coconut.dev/devcontainers) for easier config / safety
* Initialize your Coconut with `nut init` and start serving `nut serve`

You're now ready to create first change proposal and get it started:

### Use the `nut` CLI

```
> nut propose "Change the title to be 'Coconut'"
> nut code cp-001 --autonomous --new-worktree
```

### Use the Web UI

* Open [http://localhost:3000](http://localhost:3000) (which is the default port that Coconut runs on locally)
* Navigation to the proposals section and create a proposal
* From the proposal view click `Prepare Coding Agent`
* Optional `Configure` (wherein you can choose a coding agent) and click `Start Coding`

